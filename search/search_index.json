{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home Assistant Carbon Intensity","text":"<p>Custom component to use the data from carbonintensity.org.uk to make your home more energy efficient.</p>"},{"location":"#features","title":"Features","text":"<p>Below are the main features of the integration</p> <ul> <li>Current carbon intensity rating for your region</li> <li>Custom sensor support to target lowest rates</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"<p>You should take the latest published release. The current state of <code>develop</code> will be in flux and therefore possibly subject to change.</p>"},{"location":"#hacs","title":"HACS","text":"<p>While the integration isn't available in the HACS store yet, you can install it as a custom repository, providing the url <code>https://github.com/BottlecapDave/HomeAssistant-CarbonIntensity</code> and category of <code>integration</code>. Once installed, don't forget to restart your home assistant instance for the integration to be picked up.</p>"},{"location":"#manual","title":"Manual","text":"<p>To install, place the contents of <code>custom_components</code> into the <code>&lt;config directory&gt;/custom_components</code> folder of your Home Assistant installation.</p>"},{"location":"#how-to-setup","title":"How to setup","text":"<p>Please follow the setup guide to setup your initial account. This guide details the configuration, along with the entities that will be available to you.</p>"},{"location":"#entities","title":"Entities","text":"<p>A full list of default entities can be found here</p>"},{"location":"#target-rate-sensors","title":"Target Rate Sensors","text":"<p>These sensors calculate the lowest continuous or intermittent rates within a 24 hour period and turn on when these periods are active.</p> <p>These sensors can then be used in automations to turn on/off devices that save the planet from additional carbon. You can go through this flow as many times as you need target rate sensors.</p> <p>Please follow the setup guide to setup.</p>"},{"location":"#events","title":"Events","text":"<p>This integration raises several events, which can be used for various tasks like automations. For more information, please see the events docs.</p>"},{"location":"#services","title":"Services","text":"<p>This integration includes several services. Please review them in the services doc.</p>"},{"location":"#faq","title":"FAQ","text":"<p>Before raising anything, please read through the faq. If you have found a bug or have a feature request please raise it using the appropriate report template.</p>"},{"location":"entities/","title":"Entities","text":""},{"location":"entities/#current-rating","title":"Current Rating","text":"<p><code>sensor.carbon_intensity_{{REGION}}_current_rating</code></p> <p>The forecasted intensity rating of the current 30 minute period.</p> Attribute Type Description <code>rate</code> <code>object</code> The rate for the current 30 minute period <p>For the rate, you will get the following attributes</p> Attribute Type Description <code>from</code> <code>string</code> The time the rate starts. <code>to</code> <code>string</code> The time the rate ends. <code>intensity_forecast</code> <code>integer</code> The forecasted/estimated carbon intensity for the period of time. The higher the number, the more carbon. <code>generation_mix</code> <code>list</code> The splits between the different fuel sources. <p>For each generation mix, you will get the following attributes</p> Attribute Type Description <code>fuel</code> <code>string</code> The type of fuel <code>perc</code> <code>float</code> The estimated percentage the fuel source makes up in the mix."},{"location":"entities/#current-day-rates","title":"Current Day Rates","text":"<p><code>event.carbon_intensity_{{REGION}}_current_day_rates</code></p> <p>The state of this sensor states when the current day's rates were last updated. The attributes of this sensor exposes the current day's rates.</p> Attribute Type Description <code>rates</code> <code>list</code> The collection of rates for the current day <p>For each rate, you will get the following attributes</p> Attribute Type Description <code>from</code> <code>string</code> The time the rate starts. <code>to</code> <code>string</code> The time the rate ends. <code>intensity_forecast</code> <code>integer</code> The forecasted/estimated carbon intensity for the period of time. The higher the number, the more carbon. <code>generation_mix</code> <code>list</code> The splits between the different fuel sources. <p>For each generation mix, you will get the following attributes</p> Attribute Type Description <code>fuel</code> <code>string</code> The type of fuel <code>perc</code> <code>float</code> The estimated percentage the fuel source makes up in the mix."},{"location":"entities/#next-day-rates","title":"Next Day Rates","text":"<p><code>event.carbon_intensity_{{REGION}}_next_day_rates</code></p> <p>The state of this sensor states when the next day's rates were last updated. The attributes of this sensor exposes the next day's rates.</p> Attribute Type Description <code>rates</code> <code>list</code> The collection of rates for the next day <p>For each rate, you will get the following attributes</p> Attribute Type Description <code>from</code> <code>string</code> The time the rate starts. <code>to</code> <code>string</code> The time the rate ends. <code>intensity_forecast</code> <code>integer</code> The forecasted/estimated carbon intensity for the period of time. The higher the number, the more carbon. <code>generation_mix</code> <code>list</code> The splits between the different fuel sources. <p>For each generation mix, you will get the following attributes</p> Attribute Type Description <code>fuel</code> <code>string</code> The type of fuel <code>perc</code> <code>float</code> The estimated percentage the fuel source makes up in the mix."},{"location":"events/","title":"Events","text":"<p>The following events are raised by the integration. These events power various entities mentioned above. They can also be used to trigger automations. An example automation might look like the following</p> <pre><code>- alias: CI rates change\n  trigger:\n  - platform: event\n    event_type: carbon_intensity_next_day_rates\n  condition: []\n  action:\n  - event: notify_channels\n    event_data_template:\n      mode: message\n      title: OE price changes\n      message: &gt;\n        New rates available for {{ trigger.event.data.region }}. Starting value is {{ trigger.event.data.rates[0][\"intensity_forecast\"] }}\n      target: &lt;@ULU7111GU&gt;\n      length_hint: 00:00:04\n</code></pre>"},{"location":"events/#current-day-rates","title":"Current Day Rates","text":"<p><code>carbon_intensity_current_day_rates</code></p> <p>This is fired when the current day rates are updated.</p> Attribute Type Description <code>rates</code> <code>list</code> The list of rates applicable for the current day <code>region</code> <code>string</code> The region the rates are for"},{"location":"events/#next-day-rates","title":"Next Day Rates","text":"<p><code>carbon_intensity_next_day_rates</code></p> <p>This is fired when the next day rates are updated.</p> Attribute Type Description <code>rates</code> <code>list</code> The list of rates applicable for the next day <code>region</code> <code>string</code> The region the rates are for"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-do-i-increase-the-logs-for-the-integration","title":"How do I increase the logs for the integration?","text":"<p>If you are having issues, it would be helpful to include Home Assistant logs as part of any raised issue. This can be done by following the instructions outlined by Home Assistant.</p> <p>You should run these logs for about a day and then include the contents in the issue. Please be sure to remove any personal identifiable information from the logs before including them.</p>"},{"location":"services/","title":"Services","text":"<p>There are a few services available within this integration, which are detailed here.</p>"},{"location":"services/#update_target_config","title":"update_target_config","text":"<p>Service for updating a given target rate's config. This allows you to change target rates sensors dynamically based on other outside criteria (e.g. you need to adjust the target hours to top up home batteries).</p> <p>Please note this is temporary and will not persist between restarts.</p> Attribute Optional Description <code>target.entity_id</code> <code>no</code> The name of the target sensor whose configuration is to be updated <code>data.hours</code> <code>yes</code> The optional number of hours the rate sensor should come on during a 24 hour period. Must be divisible by 0.5. <code>data.start_time</code> <code>yes</code> The optional time the evaluation period should start. Must be in the format of <code>HH:MM</code>. <code>data.end_time</code> <code>yes</code> The optional time the evaluation period should end. Must be in the format of <code>HH:MM</code>. <code>data.offset</code> <code>yes</code> The optional offset to apply to the target rate when it starts. Must be in the format <code>(+/-)HH:MM:SS</code> <p>This can be used via automations in the following way. Assuming we have the following inputs.</p> <pre><code>input_number:\n  carbon_intensity_hours:\n    name: Carbon Intensity Target Hours\n    min: 0\n    max: 24\n\ninput_text:\n  # From/to would ideally use input_datetime, but we need the time in a different format\n  carbon_intensity_from:\n    name: Carbon Intensity Target From\n    initial: \"00:00\"\n  carbon_intensity_to:\n    name: Carbon Intensity Target To\n    initial: \"00:00\"\n  carbon_intensity_offset:\n    name: Carbon Intensity Target Offset\n    initial: \"-00:00:00\"\n</code></pre> <p>Then an automation might look like the following</p> <pre><code>automations:\n  - alias: Update target rate config\n    trigger:\n    - platform: state\n      entity_id:\n      - input_number.carbon_intensity_hours\n      - input_text.carbon_intensity_from\n      - input_text.carbon_intensity_to\n      - input_text.carbon_intensity_offset\n    condition: []\n    action:\n    - service: carbon_intensity.update_target_config\n      data:\n        hours: &gt;\n          \"{{ states('input_number.carbon_intensity_hours') | string }}\"\n        start_time: &gt;\n          {{ states('input_text.carbon_intensity_from') }}\n        end_time: &gt;\n          {{ states('input_text.carbon_intensity_to') }}\n        offset: &gt;\n          {{ states('input_text.carbon_intensity_offset') }}\n      target:\n        entity_id: binary_sensor.carbon_intensity_target_example\n</code></pre>"},{"location":"sponsorship/","title":"Sponsorship","text":"<p>If you are enjoying the integration, if possible, make a one off or monthly GitHub sponsorship.</p>"},{"location":"setup/core/","title":"Core","text":"<p>Setup is done entirely via the integration UI.</p> <p>This will be used to feed your various sensors</p>"},{"location":"setup/core/#region","title":"Region","text":"<p>In order to provide accurate readings, you'll need to set the region you're tracking. This will be used to work out the carbon intensity in your area.</p>"},{"location":"setup/target_rate/","title":"Target Rate Sensor(s)","text":"<p>After you've configured your core details, you'll be able to configure target rate sensors. These are configured by adding subsequent instances of the integration going through the normal flow.</p> <p>These sensors calculate the lowest continuous or intermittent rates within a 24 hour period and turn on when these periods are active.</p> <p>These sensors can then be used in automations to turn on/off devices that save the planet from additional carbon. You can go through this flow as many times as you need target rate sensors.</p> <p>Each sensor will be in the form <code>binary_sensor.carbon_intensity_target_{{TARGET_RATE_NAME}}</code>.</p>"},{"location":"setup/target_rate/#setup","title":"Setup","text":""},{"location":"setup/target_rate/#target-timeframe","title":"Target Timeframe","text":"<p>If you're wanting your devices to come on during a certain timeframe, for example while you're at work, you can set the minimum and/or maximum times for your target rate sensor. These are specified in 24 hour clock format and will attempt to find the optimum discovered period during these times.</p> <p>The <code>from/start</code> time can be set in the field <code>The minimum time to start the device</code> and the <code>to/end</code> time can be set in the field <code>The maximum time to stop the device</code>.</p> <p>If not specified, these default from <code>00:00</code> to <code>00:00</code> the following day.</p> <p>If for example you want to look at prices overnight you could set the minimum time to something like <code>20:00</code> and your maximum time to something like <code>05:00</code>. If the minimum time is \"before\" the maximum time, then it will treat the maximum time as the time for the following day.</p> <p>Info</p> <p>The target rate will not be evaluated until all rates are available for the specified timeframe. Therefore if we're looking between <code>00:00</code> and <code>00:00</code>, full rate information must exist between this time. Whereas if times are between <code>10:00</code> and <code>16:00</code>, then rate information is only needed between these times before it can be calculated.</p>"},{"location":"setup/target_rate/#hours","title":"Hours","text":"<p>The hours that you require for the sensor to find. This should be in decimal format and represent 30 minute increments. For example 30 minutes would be <code>0.5</code>, 1 hour would be <code>1</code> or <code>1.0</code>, 1 hour and 30 minutes would be <code>1.5</code>, etc.</p>"},{"location":"setup/target_rate/#offset","title":"Offset","text":"<p>You may want your target rate sensors to turn on a period of time before the optimum discovered period. For example, you may be turning on a robot vacuum cleaner for a 30 minute clean and want it to charge during the optimum period. For this, you'd use the <code>offset</code> field and set it to <code>-00:30:00</code>, which can be both positive and negative and go up to a maximum of 24 hours. This will shift when the sensor turns on relative to the optimum period. For example, if the optimum period is between <code>2023-01-18T10:00</code> and <code>2023-01-18T11:00</code> with an offset of <code>-00:30:00</code>, the sensor will turn on between <code>2023-01-18T09:30</code> and <code>2023-01-18T10:30</code>.</p>"},{"location":"setup/target_rate/#rolling-target","title":"Rolling Target","text":"<p>Depending on how you're going to use the sensor, you might want the best period to be found throughout the day so it's always available. For example, you might be using the sensor to turn on a washing machine which you might want to come on at the best time regardless of when you use the washing machine. This can result in the sensor coming on more than the target hours, and therefore should be used in conjuction with other sensors. You can activate this behaviour by setting the <code>Re-evaluate multiple times a day</code> checkbox.</p> <p>Warning</p> <p>Using this can result in the sensor coming on more than the target hours, and therefore should be used in conjunction with other sensors. </p> <p>However, you might also only want the target time to occur once a day so once the best time for that day has passed it won't turn on again. For example, you might be using the sensor to turn on something that isn't time critical and could wait till the next day like a charger. This is the default behaviour and is done by not setting the <code>Re-evaluate multiple times a day</code> checkbox.</p> <p>Info</p> <p>The next set of target times will not be calculated until all target times are in the past. This will have an effect on the <code>next</code> set of attributes on the sensor.</p>"},{"location":"setup/target_rate/#latest-period","title":"Latest Period","text":"<p>Depending on how you're going to use the sensor, you might want the best period at the latest possible time. For example, you might be using the sensor to turn on an immersion heater which you'll want to come on at the end of the cheapest found period. </p> <p>For instance if you turn this on and the cheapest period is between <code>2023-01-01T00:30</code> and <code>2023-01-01T05:00</code> and your target rate is for 1 hour, then it will come on between <code>2023-01-01T04:00</code> and <code>2023-01-01T05:00</code> instead of <code>2023-01-01T00:30</code> and <code>2023-01-01T01:30</code>.</p> <p>This feature is toggled on by the <code>Find last applicable rates</code> checkbox.</p>"},{"location":"setup/target_rate/#maximum-intensity","title":"Maximum Intensity","text":"<p>There may be times that you want the target rate sensors to not take into account intensity rates that are above a certain value (e.g. you don't want the sensor to turn on when carbon intensity is crazy).</p>"},{"location":"setup/target_rate/#attributes","title":"Attributes","text":"<p>The following attributes are available on each sensor</p> Attribute Type Description <code>name</code> <code>string</code> The name of the sensor. <code>hours</code> <code>string</code> The total hours are being discovered. <code>type</code> <code>string</code> The type/mode for the target rate sensor. This will be either <code>continuous</code> or <code>intermittent</code>. <code>rolling_target</code> <code>boolean</code> Determines if <code>Re-evaluate multiple times a day</code> is turned on for the sensor. <code>last_rates</code> <code>boolean</code> Determines if <code>Find last applicable rates</code> is turned off for the sensor. <code>offset</code> <code>string</code> The offset configured for the sensor. <code>start_time</code> <code>string</code> The start time configured for the sensor. <code>end_time</code> <code>string</code> The end time configured for the sensor. <code>rates_incomplete</code> <code>boolean</code> True if rate information is incomplete and therefore target times cannot be calculated; False otherwise. <code>target_times</code> <code>array</code> The discovered times and rates the sensor will come on for. <code>overall_average_intensity</code> <code>float</code> The average intensity of all discovered times during the current 24 hour period. <code>overall_min_intensity</code> <code>float</code> The minimum intensity of all discovered times during the current 24 hour period. <code>overall_max_intensity</code> <code>float</code> The maximum intensity of all discovered times during the current 24 hour period. <code>current_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the current continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_average_intensity</code> <code>float</code> The average intensity for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_min_intensity</code> <code>float</code> The min intensity for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>current_max_intensity</code> <code>float</code> The max intensity for the current continuous discovered period. This could be <code>none</code>/<code>unknown</code> if the sensor is not currently in a discovered period. <code>next_time</code> <code>datetime</code> The next date/time the sensor will come on. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_duration_in_hours</code> <code>float</code> The duration the sensor will be on for, for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_average_intensity</code> <code>float</code> The average intensity for the next continuous discovered period. For <code>continuous</code> sensors, this will be the entire period. For <code>intermittent</code> sensors, this could be the entire period or a portion of it, depending on the discovered times. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_min_intensity</code> <code>float</code> The average intensity for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>next_max_intensity</code> <code>float</code> The average intensity for the next continuous discovered period. This will only be populated if <code>target_times</code> has been calculated and at least one period/block is in the future. <code>target_times_last_evaluated</code> datetime The datetime the target times collection was last evaluated. This will occur if all previous target times are in the past and all rates are available for the requested future time period. For example, if you are targeting 16:00 (day 1) to 16:00 (day 2), and you only have rates up to 23:00 (day 1), then the target rates won't be calculated. <code>last_evaluated</code> <code>datetime</code> The datetime the state of the sensor was last evaluated based on the current specified target times. This should update every minute <p>For each target time, you will get the following attributes</p> Attribute Type Description <code>from</code> <code>string</code> The time the target time starts. <code>to</code> <code>string</code> The time the target time ends. <code>intensity_forecast</code> <code>integer</code> The forecasted/estimated carbon intensity for the period of time. The higher the number, the more carbon. <code>generation_mix</code> <code>list</code> The splits between the different fuel sources. <p>For each generation mix, you will get the following attributes</p> Attribute Type Description <code>fuel</code> <code>string</code> The type of fuel <code>perc</code> <code>float</code> The estimated percentage the fuel source makes up in the mix."},{"location":"setup/target_rate/#services","title":"Services","text":"<p>There are services available associated with target rate sensors. Please review them in the services doc.</p>"},{"location":"setup/target_rate/#examples","title":"Examples","text":"<p>Lets look at a few examples. Lets say we have the the following (unrealistic) set of intensity values.</p> start end value <code>2023-01-01T00:00</code> <code>2023-01-01T00:30</code> 6 <code>2023-01-01T00:30</code> <code>2023-01-01T05:00</code> 12 <code>2023-01-01T05:00</code> <code>2023-01-01T05:30</code> 7 <code>2023-01-01T05:30</code> <code>2023-01-01T18:00</code> 20 <code>2023-01-01T18:00</code> <code>2023-01-01T23:30</code> 34 <code>2023-01-01T23:30</code> <code>2023-01-02T00:30</code> 5 <code>2023-01-02T00:30</code> <code>2023-01-02T05:00</code> 12 <code>2023-01-02T05:00</code> <code>2023-01-02T05:30</code> 7 <code>2023-01-02T05:30</code> <code>2023-01-02T18:00</code> 20 <code>2023-01-02T18:00</code> <code>2023-01-02T23:00</code> 34 <code>2023-01-02T23:30</code> <code>2023-01-03T00:00</code> 6"},{"location":"setup/target_rate/#continuous","title":"Continuous","text":"<p>If we look at a continuous sensor that we want on for 1 hour.</p> <p>If we set no from/to times, then our 24 hour period being looked at ranges from <code>00:00:00</code> to <code>23:59:59</code>.</p> <p>The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T01:00</code> <code>false</code> while 5 is our lowest rate within the current 24 hour period, it doesn't cover our whole 1 hour and is next to a high 34 rate. A rate of 6 is the next available rate with a low following rate. <code>2023-01-01T01:00</code> <code>2023-01-02T00:00</code> - <code>2023-01-02T01:00</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-01T01:00</code> <code>2023-01-01T04:30</code> - <code>2023-01-01T05:30</code> <code>true</code> The rate of 6 is in the past, so 7 is our next lowest rate. 12 is smaller rate than 20 so we start in the rate period before to fill our desired hour. <code>2023-01-01T23:30</code> None <code>true</code> There is no longer enough time available in the current 24 hour period, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times for <code>05:00</code> to <code>19:00</code>, we then limit the period that we look at. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T06:00</code> <code>false</code> The rate of 12 is no longer available as it's outside of our <code>from</code> time. <code>2023-01-01T06:30</code> <code>2023-01-02T05:00</code> - <code>2023-01-02T06:00</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-01T06:30</code> <code>2023-01-01T06:30</code> - <code>2023-01-01T07:30</code> <code>true</code> The rate of 7 is in the past, so we must look for the next lowest combined rate <code>2023-01-01T18:00</code> <code>2023-01-01T18:00</code> - <code>2023-01-01T19:00</code> <code>true</code> The rate of 20 is in the past, so we must look for the next lowest combined rate which is 34 <code>2023-01-01T18:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times to look over two days, from <code>20:00</code> to <code>06:00</code>, we then limit the period that we look at to overnight. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T20:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T01:30</code> <code>false</code> Our lowest rate of 5 now falls between our overnight time period so is available <code>2023-01-02T02:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T01:30</code> <code>false</code> Our lowest period is in the past, so we have to wait until our target period has passed to look at the next evaluation period. <code>2023-01-02T02:00</code> <code>2023-01-02T04:30</code> - <code>2023-01-02T05:30</code> <code>true</code> The rate of 5 is in the past, so we must look for the next lowest combined rate, which includes our half hour rate at 7 <code>2023-01-02T05:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set an offset of <code>-00:30:00</code>, then while the times might be the same, the target rate sensor will turn on 30 minutes before the select rate period starts. Any set time restrictions will not include the offset.</p>"},{"location":"setup/target_rate/#intermittent","title":"Intermittent","text":"<p>If we look at an intermittent sensor that we want on for 1 hour total (but not necessarily together).</p> <p>If we set no from/to times, then our 24 hour period being looked at ranges from <code>00:00:00</code> to <code>23:59:59</code>.</p> <p>The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T00:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>false</code> Our sensor will go on for 30 minutes at the lowest intensity, then 30 minutes at the next lowest intensity. <code>2023-01-01T01:00</code> <code>2023-01-01T00:00</code> - <code>2023-01-01T00:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>false</code> Our sensor will go on for 30 minutes at the lowest intensity, which will be in the past, then 30 minutes at the next lowest intensity. <code>2023-01-01T01:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T23:30</code> - <code>2023-01-02T00:00</code> <code>true</code> Our sensor will go on for 30 minutes at the second lowest intensity, then 30 minutes at the third lowest intensity. <code>2023-01-01T23:30</code> None <code>true</code> There is no longer enough time available in the current 24 hour period, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times for <code>05:00</code> to <code>19:00</code>, we then limit the period that we look at. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T00:00</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T05:30</code> - <code>2023-01-01T06:00</code> <code>false</code> Our lowest intensities are outside our target range, so we need to look at the next cheapest. Luckily on our scenario the two lowest intensities are next to each other. <code>2023-01-01T06:30</code> <code>2023-01-01T05:00</code> - <code>2023-01-01T05:30</code>, <code>2023-01-01T05:30</code> - <code>2023-01-01T06:00</code> <code>false</code> Both of our lowest intensities in the target range are in the past. <code>2023-01-01T06:30</code> <code>2023-01-01T06:30</code> - <code>2023-01-01T07:00</code>, <code>2023-01-01T07:00</code> - <code>2023-01-01T07:30</code> <code>true</code> Both of our lowest intensities in the target range are in the past, so we must look for the next lowest combined rate <code>2023-01-01T18:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set our from/to times to look over two days, from <code>20:00</code> to <code>06:00</code>, we then limit the period that we look at to overnight. The following table shows what this would be like.</p> current date/time period <code>Re-evaluate multiple times a day</code> reasoning <code>2023-01-01T20:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T00:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>false</code> Our lowest rate of 5 now falls between our overnight time period so is available <code>2023-01-02T02:00</code> <code>2023-01-01T23:30</code> - <code>2023-01-02T00:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>false</code> Our lowest period is in the past, but we still have a rate in the future so our sensor will only come on once. <code>2023-01-02T02:00</code> <code>2023-01-02T02:00</code> - <code>2023-01-02T02:30</code>, <code>2023-01-02T05:00</code> - <code>2023-01-02T05:30</code> <code>true</code> The rate of 5 is in the past, so we must look for the next lowest combined rate, which includes our half hour rate at 7 <code>2023-01-02T05:30</code> None <code>true</code> There is no longer enough time available within our restricted time, so we have to wait until our target period has passed to look at the next evaluation period. <p>If we set an offset of <code>-00:30:00</code>, then while the times might be the same, the target rate sensor will turn on 30 minutes before the select rate period starts. Any set time restrictions will not include the offset.</p>"}]}